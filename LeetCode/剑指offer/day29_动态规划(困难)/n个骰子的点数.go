// 题目链接：https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/?envType=study-plan&id=lcof
// day28/31
// 第 28 天主题为：搜索与回溯算法（困难）
// 包含三道题目：
// 剑指offer19.正则表达式匹配
// 剑指offer49.丑数
// 剑指offer60.n个骰子的点数
package main

//这道题我的第一反应是做排列组合问题。看题解才知道是 dp 问题。

//1 个骰子共有 6 中可能的点数，两个骰子点数范围为 [2,12]，共有 11 种可能的点数，对 n 个骰子，点数范围为 [n,6*n]，共有 5 * n + 1 种可能的点数。
//
//如果我们知道了 x-1 个骰子所有的点数及其概率，那 x 个骰子的点数及其概率可以通过其推出。对 x 个骰子，也就是在 x-1 的基础上添加一个骰子，
//该骰子的点数可为 1-6，每个点数的概率均为 1/6，那我们可以对 x-1 个骰子的点数进行遍历，再对 1-6 开启第二层遍历，设当前遍历到 x-1 个骰子的点数为 m，
//第 x 个骰子遍历到的点数为 n，那么 dp[i][m+n] += dp[x-1][m]/6
//
//动态规划三步：
//1. 确定dp数组及下标含义：dp[i][j] 代表 i 个骰子 点数为 j 的概率，则 len(dp) = n+1, len(dp[0]) = 6*n+1
//2. 数组初始化：一个骰子的点数及其概率我们是已知的，dp[1][1] - dp[1][6] 的值均为 1/6，dp 数组中其余值初始化为 0 即可，其余有效信息将由 1 个骰子的点数及其概率得出。
//3. 状态转移方程
//
//dp[n][x]=\sum_{i=1}^6dp[n-1][x-i]*1/6
//
//可以看出，该状态转移方程是一个理论上合理的方案，但用此公式求解的话，需要考虑越界的问题，是一种逆向的递推公式，我们将其改为正向即可，
//通过 x-1 个骰子的点数推导 x 个骰子的点数。

func dicesProbability(n int) []float64 {
	// dp数组初始化
	dp := make([][]float64,n+1)
	for i:=0;i<n+1;i++{
		dp[i] = make([]float64,6*n+1)
	}
	for i:=1;i<=6;i++{
		dp[1][i] = float64(1)/float64(6)
	}
	// 已知1个骰子的点数及其概率，向后推导至n个骰子的点数
	for i:=2;i<=n;i++{
		// 通过 i-1 个骰子的点数，求第 i 个骰子的点数
		for j:=i-1;j<=6*(i-1);j++{
			// 每个骰子的点数为1-6，概率均为1/6
			for k:=1;k<=6;k++{
				dp[i][j+k] += (dp[i-1][j])/6
			}
		}
	}
	return dp[n][n:]
}

//另外，感觉这道题是 dp 思路很好的练习题目
//一个阶段有个多个状态，且当前阶段的每个状态会影响到下一个阶段的多个状态（至多6个）