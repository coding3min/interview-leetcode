### 内存使用情况buff和cache有什么区别？

* 都是为了解决内存和IO设备的读写速度不对等的中间缓存，两个都是内存的一部分
* cached 把读取过的数据保存起来，重新读取的时候命中就不用读磁盘了，如果没有命中就会按频率更新cached
* buffers 把分散的写操作集中起来，缓存要输出到io设备的数据（写一次就存一下硬盘贼耗时间，都是缓冲一会再一起写硬盘）
* 拓展一个shared，是共享内存，可以ipcs来查看

### 怎么定位进程cpu占用大是哪一个函数导致的？

``` bash

perf top -g -p 246
```

![](../res/2021-03-17-19-59-30.png)

这里推荐

![优惠口令： Happy2021](../res/2021-03-17-19-59-39.png)

### 什么是程序的堆空间和栈空间？

回答者：海翔

栈是用来保证程序顺序执行的，后入栈的函数先出，完整记录一个函数（方法）调用从开始到结束所做的一切操作。

堆是用来保存变量和对象的，存储临时数据和部分运行时数据。包括函数调用期间产生的临时变量，程序加载启动时载入的全局变量等等。堆内存的分配，应该是在临时变量第一次被使用时分配，全局静态变量是在类加载时分配。不同的变量有不同的生命周期。而垃圾回收，主要也是针对堆内存空间的调整和释放

栈和堆都有其空间大小。

当递归层级过深时会出现栈溢出异常，就是因为要保存的方法栈超过了栈可保存的最大数量。而堆内存不足时常常会遇到OOM异常，堆内存不足以存放新生成的对象或变量了。

### 虚拟地址和物理地址有什么区别，程序编译运行后首先申请到的是什么地址？

因为位数代表最大寻址能力，32位最大寻址能力是4G所以超过4g的内存条会造成浪费

我们知道线程是cpu调度的最小单元，进程是资源分配的最小单元，每个进程之间的资源是独立的，互不影响的，这是怎么实现的呢？

每个进程启动的时候会有独立内存空间，称为虚拟内存，启动时为给每个进程维护一个独立的页表做虚拟内存和物理内存的映射

所以不同进程之间的虚拟内存地址可能是相同的，这没关系，最终映射到的是物理内存不是一个

假如不同进程都访问某个系统的库，就不需要加载两遍到物理内存上，只要映射到同一地址范围就可以

用到了再分配这种机制叫内存的惰性加载。

虚拟内存寻址是cpu到一个叫mmu的硬件，物理内存寻址是mmu到内存条，mmu相当于是个外包

所以虚拟内存虽然大，不一定全部都存在映射，之前说的堆栈空间也是在虚拟内存中的

### Linux 打开文件句柄写入一个文件时，mv这个文件会发生什么

mv操作，目标文件的inode将等于源文件的inode；因此正在写入的文件被mv，数据仍然被写入到mv后的文件里，除非重新open

正在写入的文件被rm后，数据会被写入到系统缓存中，一直会耗尽所有可用的内存

### 日志归档和清空有哪些方式

归档：logrotate 支持归档和删除长期日志

代码级别可以使用滚动日志组件

如果是手动删除可以使用cat /dev/null > xxx.log

### 查询linux文件被哪些pid读写的命令是什么

``` BASH
lsof abc.txt 显示开启文件abc.txt的进程
lsof -i :22 知道22端口现在运行什么程序
lsof -c nsd 显示nsd进程现在打开的文件
lsof -g gid 显示归属gid的进程情况
lsof +d /usr/local/ 显示目录下被进程开启的文件
lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长
lsof -d 4 显示使用fd为4的进程
lsof -i [i] 用以显示符合条件的进程情况
```

### 查看子进程的命令

这里的 `722` 是指进程 `pid`

``` BASH
pstree -p 722
```

### 查看线程号

这里的 `722` 是指进程 `pid`

``` BASH
ps -T -p 722
```

### 查看线程cpu使用率

``` BASH
top -H -p 722
```

### 获取URL中协议、域名、端口和Path

``` BASH
#获取协议
echo "http://www.baidu.com:80/ABCD/a.txt" | awk -F':' '{print $1}'
# 输出http

#获取域名
echo "http://www.baidu.com:80/ABCD/a.txt" | awk -F'[/:]' '{print $4}'
# 输出：www.baidu.com

#获取端口
echo "http://www.baidu.com:80/ABCD/a.txt" | awk -F'[/:]' '{print $5}'
# 输出 80

#获取Path
echo "http://www.baidu.com:80/ABCD/a.txt" | cut -d/ -f4-
# 输出 ABCD/a.txt
```

### 如果linux系统卡死，操作系统比较慢，排查思路？

* 先使用top实时查看一下进程占cpu以及内存的情况，因为top是实时刷新的，比较直观
* 有时候刷新太快，进一步使用`ps -aux`可以查看哪些进程占cpu或者内存较高，如果需要急切恢复，可以`kill -9`杀进程来恢复。
* 有可能此进程只是一个子进程，那要使用`ps -ef | grep 进程ID`查找父进程

看哪些日志

* messages日志，`/var/log`目录下，比较全，关键字`failed`、`error`、`false`，查看开机时间`Runtime journal`
* 服务日志
* dmesg日志，该日志是记录系统最近一次开机时加载的驱动信息，以及开机后键鼠等硬件的一些响应信息
* 如果是图形化服务器，查看`Xorg.0.log`日志，该日志是记录的图形化服务相关的一些日志信息，看一下图形化服务方面有什么异常没
* `.xsession-errors`日志，`root`用户在`/root`下，普通用户在`/home/username/`下），是隐藏文件，该日志信息是某用户环境下的图形化日志信息
* `lightdm.log`日志，该日志是和登录界面相关的一些日志信息，如果系统卡死的时候是在用户登录界面的时候卡死了，这个日志就有必要也看一眼
* 最后有可能是硬件问题

### 最后

如果文中有误，欢迎提pr或者issue，**一旦合并或采纳作为贡献奖励可以联系我直接无门槛**加入[技术交流群](https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q)

我是小熊，关注我，知道更多不知道的技术

![](../res/2021-03-17-19-57-33.png)
