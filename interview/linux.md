# Linux

## VIM 三个模式

* 一般指令模式（默认模式）
* 编辑模式
* 指令列模式

## 文件属性

* 用户分为三种
  * 文件拥有者
  * 群组
  * 其它人
* 文件类型
  * d：目录
  * -：文件
  * l：链接文件
* 文件权限：
  * 三位一组
  * 对文件拥有者、所属群组以及其它人的文件权限
  * 3 位分别为 `r、w、x` 权限，表示可读、可写、可执行
* 文件时间
  * `modification time (mtime)`：文件的内容更新就会更新；
  * `status time (ctime)`：文件的状态（权限、属性）更新就会更新；
  * `access time (atime)`：读取文件时就会更新。
* 修改权限
  * `chmod`
  * 左到右每个位的权值为 4、2、1
* 默认权限
  * 文件默认权限`666`
  * 目录默认权限`777`

## 链接

* 实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。
* 符号链接：文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式
* ln创建链接：默认是实体链接，加 -s 为符号链接

![](.gitbook/assets/2021-03-26-16-29-48.png)

## 获取文件内容

* cat、tac\(从最后一行打印\)
* more（一页一页打印）、less（增加向前翻页）
* head（前n行）、tail（后几行）

## 数据流重定向

* 一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向
* 输出重定向到 `/dev/null`（扔进垃圾箱）

## 排序指令（sort）

```bash
$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间

$ uniq [-ic](可以将重复的数据只取一个)
-i ：忽略大小写
-c ：进行计数
```

## 正则表达式\(grep\)

```text
$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计匹配到行的个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
```

## 查看进程

* ps -l 查看自己的进程
* ps aux 查看系统所有进程
* pstree 查看进程数

## 查看子进程的命令

这里的 `722` 是指进程 `pid`

```bash
pstree -p 722
```

## 查看线程号

这里的 `722` 是指进程 `pid`

```bash
ps -T -p 722
```

## 查看线程cpu使用率

```bash
top -H -p 722
```

## 查询linux文件被哪些pid读写

```bash
lsof abc.txt 显示开启文件abc.txt的进程
lsof -i :22 知道22端口现在运行什么程序
lsof -c nsd 显示nsd进程现在打开的文件
lsof -g gid 显示归属gid的进程情况
lsof +d /usr/local/ 显示目录下被进程开启的文件
lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长
lsof -d 4 显示使用fd为4的进程
lsof -i [i] 用以显示符合条件的进程情况
```

## 获取URL中协议、域名、端口和Path

```bash
#获取协议
echo "http://www.baidu.com:80/ABCD/a.txt" | awk -F':' '{print $1}'
# 输出http

#获取域名
echo "http://www.baidu.com:80/ABCD/a.txt" | awk -F'[/:]' '{print $4}'
# 输出：www.baidu.com

#获取端口
echo "http://www.baidu.com:80/ABCD/a.txt" | awk -F'[/:]' '{print $5}'
# 输出 80

#获取Path
echo "http://www.baidu.com:80/ABCD/a.txt" | cut -d/ -f4-
# 输出 ABCD/a.txt
```

## 内存

### 内存使用情况buff和cache有什么区别？

* 都是为了解决内存和IO设备的读写速度不对等的中间缓存，两个都是内存的一部分
* cached 把读取过的数据保存起来，重新读取的时候命中就不用读磁盘了，如果没有命中就会按频率更新cached
* buffers 把分散的写操作集中起来，缓存要输出到io设备的数据（写一次就存一下硬盘贼耗时间，都是缓冲一会再一起写硬盘）
* 拓展一个shared，是共享内存，可以ipcs来查看

## 虚拟地址和物理地址有什么区别，程序编译运行后首先申请到的是什么地址？

因为位数代表最大寻址能力，32位最大寻址能力是4G所以超过4g的内存条会造成浪费

我们知道线程是cpu调度的最小单元，进程是资源分配的最小单元，每个进程之间的资源是独立的，互不影响的，这是怎么实现的呢？

每个进程启动的时候会有独立内存空间，称为虚拟内存，启动时为给每个进程维护一个独立的页表做虚拟内存和物理内存的映射

所以不同进程之间的虚拟内存地址可能是相同的，这没关系，最终映射到的是物理内存不是一个

假如不同进程都访问某个系统的库，就不需要加载两遍到物理内存上，只要映射到同一地址范围就可以

用到了再分配这种机制叫内存的惰性加载。

虚拟内存寻址是cpu到一个叫mmu的硬件，物理内存寻址是mmu到内存条，mmu相当于是个外包

所以虚拟内存虽然大，不一定全部都存在映射，之前说的堆栈空间也是在虚拟内存中的

## 运维

### 怎么定位进程cpu占用大是哪一个函数导致的？

```bash
perf top -g -p 246
```

![](.gitbook/assets/2021-03-17-19-59-30.png)

这里推荐

![&#x4F18;&#x60E0;&#x53E3;&#x4EE4;&#xFF1A; Happy2021](.gitbook/assets/2021-03-17-19-59-39.png)

## 什么是程序的堆空间和栈空间？

回答者：海翔

栈是用来保证程序顺序执行的，后入栈的函数先出，完整记录一个函数（方法）调用从开始到结束所做的一切操作。

堆是用来保存变量和对象的，存储临时数据和部分运行时数据。包括函数调用期间产生的临时变量，程序加载启动时载入的全局变量等等。堆内存的分配，应该是在临时变量第一次被使用时分配，全局静态变量是在类加载时分配。不同的变量有不同的生命周期。而垃圾回收，主要也是针对堆内存空间的调整和释放

栈和堆都有其空间大小。

当递归层级过深时会出现栈溢出异常，就是因为要保存的方法栈超过了栈可保存的最大数量。而堆内存不足时常常会遇到OOM异常，堆内存不足以存放新生成的对象或变量了。

## 日志归档和清空有哪些方式

归档：logrotate 支持归档和删除长期日志

代码级别可以使用滚动日志组件

如果是手动删除可以使用cat /dev/null &gt; xxx.log

## 如果linux系统卡死，操作系统比较慢，排查思路？

* 先使用top实时查看一下进程占cpu以及内存的情况，因为top是实时刷新的，比较直观
* 有时候刷新太快，进一步使用`ps -aux`可以查看哪些进程占cpu或者内存较高，如果需要急切恢复，可以`kill -9`杀进程来恢复。
* 有可能此进程只是一个子进程，那要使用`ps -ef | grep 进程ID`查找父进程

看哪些日志

* messages日志，`/var/log`目录下，比较全，关键字`failed`、`error`、`false`，查看开机时间`Runtime journal`
* 服务日志
* dmesg日志，该日志是记录系统最近一次开机时加载的驱动信息，以及开机后键鼠等硬件的一些响应信息
* 如果是图形化服务器，查看`Xorg.0.log`日志，该日志是记录的图形化服务相关的一些日志信息，看一下图形化服务方面有什么异常没
* `.xsession-errors`日志，`root`用户在`/root`下，普通用户在`/home/username/`下），是隐藏文件，该日志信息是某用户环境下的图形化日志信息
* `lightdm.log`日志，该日志是和登录界面相关的一些日志信息，如果系统卡死的时候是在用户登录界面的时候卡死了，这个日志就有必要也看一眼
* 最后有可能是硬件问题

## epoll 相比于 select 模型具备的优势：

epoll 处理事件流模型是线程安全的；

epoll 跟 select 模型相比调用 fd 文件描述符时使用了 mmap 共享用户和内核的部分空间，提高了效率；

epoll 是基于事件驱动的，相比 select 需要扫描整个文件描述符的相关状态，epoll 基于事件驱动避免频繁扫描文件描述符，可以直接调用 callback 回调函数，效率更高；

取消了 select 模型里面单个进程能够监视的文件描述符的数量存在的最大限制（1024），如果你有使用过早期的 Apache 版本的，它使用的select 模型，当请求超过 1000 以后就会出现延迟或者请求错误，而改用 Nginx 的话性能会得到明显的改善。

## 发散问题

### Linux 打开文件句柄写入一个文件时，mv这个文件会发生什么

mv操作，目标文件的inode将等于源文件的inode；因此正在写入的文件被mv，数据仍然被写入到mv后的文件里，除非重新open

正在写入的文件被rm后，数据会被写入到系统缓存中，一直会耗尽所有可用的内存

## 最后

如果文中有误，欢迎提pr或者issue，**一旦合并或采纳作为贡献奖励可以联系我直接无门槛**加入[技术交流群](https://mp.weixin.qq.com/s/ErQFjJbIsMVGjIRWbQCD1Q)

我是小熊，关注我，知道更多不知道的技术

![](.gitbook/assets/2021-03-17-19-57-33.png)

